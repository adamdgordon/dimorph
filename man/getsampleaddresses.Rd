% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dimorph_0.1_functions_analyses_2024-07-16.r
\name{getsampleaddresses}
\alias{getsampleaddresses}
\title{Get Resampling Addresses for Comparative Sample for Estimating Dimorphism}
\usage{
getsampleaddresses(
  comparative,
  struc,
  compsex = NULL,
  sex.female = 1,
  nResamp = 10000,
  exact = F,
  limit = 5e+05,
  matchvars = F,
  replace = F
)
}
\arguments{
\item{comparative}{A matrix or data frame of measurements from a comparative sample, with rows
corresponding to individual specimens and columns corresponding to size variables.  Sex data
should not be included.  If \code{comparative} contains \code{NA}s then \code{struc} must be supplied
as a vector rather than as a matrix or data frame.}

\item{struc}{Structure information for the data set being compared against, typically one or 
more fossil samples with missing data. \code{struc} must be either (1) a matrix or dataframe
of measurements (which can include \code{NA}s) or (2) a vector of integer sample sizes for each
variable.}

\item{compsex}{A vector indicating sex for the individuals in \code{comparative}.  Sex
information is not included in any calculations in this function but will be included
as a list element in the returned object.  Defaults to \code{NULL}.}

\item{sex.female}{An integer scalar (1 or 2) specifying which level of \code{sex} 
corresponds to female.  Ignored if \code{sex} is \code{NULL}.  Defaults to 1.}

\item{nResamp}{Integer specifying the number of resampling iterations to use when \code{exact} is
\code{FALSE} or when \code{exact} is \code{TRUE} but the total number of unique combinations exceeds
\code{limit}.}

\item{exact}{Logical scalar specifying whether or not to sample exactly once all possible 
unique combinations of the comparative data matching the pattern in \code{struc}.  This 
procedure takes into account any missing data pattern in \code{struc}.  For example, for 
three observations, "ABC" and "CAB" are identical samples if there is no missing data, but
they are different samples if the first observation has a missing data pattern that differs
from that of the second and third observations. \code{exact} defaults 
to \code{FALSE}.  If \code{FALSE}, Monte Carlo sampling is used instead.}

\item{limit}{An upper limit for the number of unique samples allowable for exact resampling.
if \code{exact} is \code{TRUE} and the number of unique combinations would exceed \code{limit} 
then Monte Carlo sampling is used instead.  \code{limit} is ignored if \code{exact} is \code{FALSE}.}

\item{matchvars}{Logical scalar specifying whether to compare the variable names in
\code{comparative} and \code{struc} and pare them both down to the set of shared variables. 
If \code{FALSE} and variable names differ then an error will be returned.  Defaults to
\code{FALSE}.}

\item{replace}{Logical scalar passed to \code{\link[base]{sample}} specifying whether or not
to sample with replacement.  Defaults to \code{FALSE}.}
}
\value{
A list of class \code{dimorphAds} containing resampled addresses and the information used to 
  generate them.
}
\description{
Function called by other functions in package \code{'dimorph'} to generate a set of resampled addresses in a 
  dataset for use in resampling analyses of dimorphism.
}
\examples{
## Univariate addresses
SSDvars <- c("HHMaj")
addressesUni <- getsampleaddresses(
     comparative=apelimbart[apelimbart$Species=="Gorilla gorilla", SSDvars, drop=FALSE],
     struc=fauxil[fauxil$Species=="Fauxil sp. 1", SSDvars, drop=FALSE],
     compsex=apelimbart[apelimbart$Species=="Gorilla gorilla", "Sex"],
     exact=TRUE, matchvars=TRUE, replace=FALSE)
addressesUni
str(addressesUni)

## Multivariate addresses
SSDvars <- c("HHMaj","RHMaj","FHSI","TPML")
addressesMulti1 <- getsampleaddresses(
     comparative=apelimbart[apelimbart$Species=="Gorilla gorilla", SSDvars],
     struc=fauxil[fauxil$Species=="Fauxil sp. 1", SSDvars],
     compsex=apelimbart[apelimbart$Species=="Gorilla gorilla", "Sex"],
     nResamp=10000, matchvars=TRUE, replace=FALSE)
addressesMulti1
str(addressesMulti1)

addressesMulti2 <- getsampleaddresses(
     comparative=apelimbart[apelimbart$Species=="Gorilla gorilla", SSDvars],
     struc=setNames(c(2,2,4,5), SSDvars),
     compsex=apelimbart[apelimbart$Species=="Gorilla gorilla", "Sex"],
     nResamp=10000, matchvars=TRUE, replace=FALSE)
addressesMulti2
str(addressesMulti2)

addressesMulti3 <- getsampleaddresses(
     comparative=apelimbart[apelimbart$Species=="Gorilla gorilla", "FHSI"],
     struc=setNames(4, "FHSI"),
     compsex=apelimbart[apelimbart$Species=="Gorilla gorilla", "Sex"],
     nResamp=10000, matchvars=TRUE, replace=FALSE)
addressesMulti3
str(addressesMulti3)

# Now with missing data also in the comparative sample
SSDvars <- c("FHSI", "TPML", "TPMAP", "TPLAP", "HHMaj",
             "HHMin", "RHMaj", "RDAP", "RDML")
Fs1 <- fauxil[fauxil$Species=="Fauxil sp. 1", SSDvars]
Fs2 <- fauxil[fauxil$Species=="Fauxil sp. 2", SSDvars]
n.Fs1 <- apply(Fs1, 2, function(x) sum(!is.na(x)))
n.Fs2 <- apply(Fs2, 2, function(x) sum(!is.na(x)))
n.Fs1
n.Fs2
n.min <- apply(rbind(n.Fs1,n.Fs2), 2, min)
gorAds <- getsampleaddresses(
     comparative=apelimbart[apelimbart$Species=="Gorilla gorilla", SSDvars],
     struc=Fs1,
     exact=TRUE, limit=500000, replace=FALSE)
gorAds
str(gorAds)

Fs1Ads <- getsampleaddresses(comparative=Fs1, struc=n.min,
                             exact=TRUE, limit=500000, replace=FALSE)
Fs1Ads
str(Fs1Ads)

Fs1AdsReplace <- getsampleaddresses(comparative=Fs1, struc=n.min,
                                    exact=TRUE, limit=500000, nResamp=1000,
                                    replace=TRUE)
Fs1AdsReplace
str(Fs1AdsReplace)

Fs2Ads <- getsampleaddresses(comparative=Fs2, struc=n.min,
                             exact=TRUE, limit=500000, replace=FALSE)
Fs2Ads
str(Fs2Ads)
}
\seealso{
\code{\link{resampleSSD}}
}
